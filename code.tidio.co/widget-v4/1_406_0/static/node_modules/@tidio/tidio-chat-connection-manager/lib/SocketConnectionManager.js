var __assign =
  (this && this.__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign.apply(this, arguments);
  };
var __spreadArray =
  (this && this.__spreadArray) ||
  function (to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
import cloneDeep from "lodash.clonedeep";
import io from "socket.io-client";
var SocketConnectionManager = /** @class */ (function () {
  function SocketConnectionManager(
    socketsUrl,
    debugMode,
    additionalParameters,
    setEmitQueueConstantParameters
  ) {
    if (debugMode === void 0) {
      debugMode = false;
    }
    if (additionalParameters === void 0) {
      additionalParameters = {};
    }
    if (setEmitQueueConstantParameters === void 0) {
      setEmitQueueConstantParameters = undefined;
    }
    var _this = this;
    this.socketsUrl = socketsUrl;
    this.debugMode = debugMode;
    this.additionalParameters = additionalParameters;
    this.setEmitQueueConstantParameters = setEmitQueueConstantParameters;
    this.socketsConnected = false;
    this.listeners = [];
    this.listenersCallbacks = [];
    this.dynamicListenersQueue = [];
    this.dynamicListenersCallbacks = {};
    this.socket = null;
    this.toEmit = [];
    this.runAsFirstEmitOnConnect = [];
    this.beforeConnectStarts = null;
    this.managerAndSocketEventsActions = {};
    /**
     * This can be replaced with `setSocketEmitWrapper` in userland code
     */
    // eslint-disable-next-line class-methods-use-this
    this.socketEmitWrapper = function (emitName, dataToSend, newAck, callback) {
      callback(emitName, dataToSend, newAck);
    };
    this.listenWithStore = null;
    this.initialRequiredEmitsAck = [];
    this.requiredEmitsAckLeft = [];
    this.toEmitAfterRequiredEmitsAck = [];
    this.isDebugMode = function () {
      return _this.debugMode;
    };
    this.setEmitQueueConstantParametersFunction = function (callback) {
      _this.setEmitQueueConstantParameters = callback;
    };
    this.closeConnection = function (closeCallback) {
      var _a;
      if ((_a = _this.socket) === null || _a === void 0 ? void 0 : _a.io) {
        // eslint-disable-next-line no-underscore-dangle
        _this.socket.io._autoConnect = false;
      }
      if (_this.socket && typeof _this.socket.close === "function") {
        _this.socket.close();
      }
      _this.listenersCallbacks.forEach(function (callback) {
        return callback();
      });
      _this.listenersCallbacks = [];
      Object.values(_this.dynamicListenersCallbacks).forEach(function (
        callback
      ) {
        return callback();
      });
      _this.dynamicListenersCallbacks = {};
      if (_this.isDebugMode()) {
        // eslint-disable-next-line no-console
        console.debug("closed!!");
      }
      if (typeof closeCallback === "function") {
        closeCallback();
      }
    };
    this.runAsFirstEmit = function (store, callback) {
      var _a;
      var pushToEmitQueueFunction =
        (_a = _this.getPushToEmitQueueFunction) === null || _a === void 0
          ? void 0
          : _a.call(_this, store.getState, store.dispatch);
      var previousToEmit = cloneDeep(_this.toEmit);
      _this.toEmit = [];
      var data = callback(store.getState, store.dispatch);
      pushToEmitQueueFunction === null || pushToEmitQueueFunction === void 0
        ? void 0
        : pushToEmitQueueFunction.apply(
            void 0,
            __spreadArray([data.emit], data.args, false)
          );
      _this.toEmit = __spreadArray(
        __spreadArray([], _this.toEmit, true),
        previousToEmit,
        true
      );
    };
    this.addToEmitQueueWithStore = function (currentState) {
      return function (emitName, args, ack) {
        var _a;
        if (ack === void 0) {
          ack = null;
        }
        var newArgs = cloneDeep(args !== null && args !== void 0 ? args : {});
        (_a = _this.setEmitQueueConstantParameters) === null || _a === void 0
          ? void 0
          : _a.call(_this, newArgs, emitName, currentState);
        _this.toEmit.push([emitName, newArgs, ack]);
        _this.runFirstEmitFromQueue();
      };
    };
    this.createEmitQueue = function () {
      return function (getState, dispatch) {
        return function (innerEmit) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          var currentState = getState();
          var addedTo = _this.addToEmitQueueWithStore(currentState);
          return innerEmit.apply(
            void 0,
            __spreadArray([addedTo, currentState, dispatch], args, false)
          );
        };
      };
    };
    this.createListenWithStore = function (_a, history) {
      var getState = _a.getState,
        dispatch = _a.dispatch;
      return function (fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (_this.socket) {
          fn.apply(
            void 0,
            __spreadArray(
              [_this.socket, getState, dispatch, history],
              args,
              false
            )
          );
        }
      };
    };
    this.bindManagerHandlers = function (store) {
      var _a, _b;
      if (_this.socket) {
        var manager =
          (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.io;
        var toEmitQueue_1 =
          (_b = _this.getPushToEmitQueueFunction) === null || _b === void 0
            ? void 0
            : _b.call(_this, store.getState, store.dispatch);
        manager.on("open", function () {
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("manager open");
          }
          if (
            typeof _this.managerAndSocketEventsActions.open === "function" &&
            toEmitQueue_1
          ) {
            _this.managerAndSocketEventsActions.open(store, toEmitQueue_1);
          }
        });
        manager.on("error", function (error) {
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("manager error", error);
          }
          if (typeof _this.managerAndSocketEventsActions.error === "function") {
            _this.managerAndSocketEventsActions.error(store, error);
          }
        });
        manager.on("ping", function () {
          if (typeof _this.managerAndSocketEventsActions.ping === "function") {
            _this.managerAndSocketEventsActions.ping();
          }
        });
        manager.on("reconnect", function (number) {
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("manager reconnect", number);
          }
          if (
            typeof _this.managerAndSocketEventsActions.reconnect ===
              "function" &&
            toEmitQueue_1
          ) {
            _this.managerAndSocketEventsActions.reconnect(
              store,
              toEmitQueue_1,
              number
            );
          }
        });
        manager.on("reconnect_attempt", function (attempt) {
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("manager reconnect_attempt");
          }
          if (
            typeof _this.managerAndSocketEventsActions.reconnect_attempt ===
              "function" &&
            toEmitQueue_1
          ) {
            _this.managerAndSocketEventsActions.reconnect_attempt(
              store,
              toEmitQueue_1,
              attempt
            );
          }
        });
        manager.on("reconnect_error", function (error) {
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("manager reconnect_error", error);
          }
          if (
            typeof _this.managerAndSocketEventsActions.reconnect_error ===
              "function" &&
            toEmitQueue_1
          ) {
            _this.managerAndSocketEventsActions.reconnect_error(
              store,
              toEmitQueue_1,
              error
            );
          }
        });
        manager.on("reconnect_failed", function () {
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("manager reconnect_failed");
          }
          if (
            typeof _this.managerAndSocketEventsActions.reconnect_failed ===
              "function" &&
            toEmitQueue_1
          ) {
            _this.managerAndSocketEventsActions.reconnect_failed(
              store,
              toEmitQueue_1
            );
          }
        });
      }
    };
    this.connectToSockets = function (
      store,
      history,
      connectCallback,
      disconnectCallback,
      additionalParametersAddedOnConnect
    ) {
      if (connectCallback === void 0) {
        connectCallback = function () {};
      }
      if (disconnectCallback === void 0) {
        disconnectCallback = function () {};
      }
      if (additionalParametersAddedOnConnect === void 0) {
        additionalParametersAddedOnConnect = {};
      }
      var defaultParameters = {
        reconnection: true,
        transports: ["websocket"],
      };
      _this.socket = io(
        _this.socketsUrl,
        __assign(
          __assign(__assign({}, defaultParameters), _this.additionalParameters),
          additionalParametersAddedOnConnect
        )
      );
      if (typeof _this.beforeConnectStarts === "function") {
        _this.beforeConnectStarts(store.dispatch, store);
      }
      _this.listenWithStore = _this.createListenWithStore(store, history);
      _this.socket.on("connect", function () {
        var _a;
        _this.socketsConnected = true;
        if (_this.isDebugMode()) {
          // eslint-disable-next-line no-console
          console.debug("connected to sockets");
        }
        _this.requiredEmitsAckLeft = __spreadArray(
          [],
          _this.initialRequiredEmitsAck,
          true
        );
        if (_this.runAsFirstEmitOnConnect.length > 0) {
          _this.runAsFirstEmitOnConnect.forEach(function (callback) {
            return _this.runAsFirstEmit(store, callback);
          });
        }
        if (_this.dynamicListenersQueue.length) {
          _this.dynamicListenersQueue.forEach(function (item) {
            var _a;
            var callback =
              (_a = _this.listenWithStore) === null || _a === void 0
                ? void 0
                : _a.call(_this, item.listener);
            if (typeof callback === "function") {
              _this.dynamicListenersCallbacks[item.key] = callback;
            }
          });
        }
        _this.dynamicListenersQueue = [];
        _this.runFirstEmitFromQueue();
        var toEmitQueue =
          (_a = _this.getPushToEmitQueueFunction) === null || _a === void 0
            ? void 0
            : _a.call(_this, store.getState, store.dispatch);
        if (
          typeof _this.managerAndSocketEventsActions.connect === "function" &&
          toEmitQueue
        ) {
          _this.managerAndSocketEventsActions.connect(
            store,
            toEmitQueue,
            history,
            connectCallback,
            disconnectCallback
          );
        }
      });
      _this.socket.on("disconnect", function (reason, description) {
        _this.socketsConnected = false;
        if (_this.isDebugMode()) {
          // eslint-disable-next-line no-console
          console.debug("sockets disconnect");
        }
        if (
          typeof _this.managerAndSocketEventsActions.disconnect === "function"
        ) {
          _this.managerAndSocketEventsActions.disconnect(
            store,
            reason,
            description
          );
        }
      });
      _this.socket.on("connect_error", function (error) {
        var _a;
        _this.socketsConnected = false;
        var toEmitQueue =
          (_a = _this.getPushToEmitQueueFunction) === null || _a === void 0
            ? void 0
            : _a.call(_this, store.getState, store.dispatch);
        if (_this.isDebugMode()) {
          // eslint-disable-next-line no-console
          console.debug("sockets connect_error");
        }
        if (
          typeof _this.managerAndSocketEventsActions.connect_error ===
            "function" &&
          toEmitQueue
        ) {
          _this.managerAndSocketEventsActions.connect_error(
            store,
            toEmitQueue,
            error
          );
        }
      });
      _this.listeners.forEach(function (listener) {
        var _a;
        var callback =
          (_a = _this.listenWithStore) === null || _a === void 0
            ? void 0
            : _a.call(_this, listener);
        if (typeof callback === "function") {
          _this.listenersCallbacks.push(callback);
        }
      });
      _this.bindManagerHandlers(store);
    };
    this.setListeners = function (listenersParam) {
      _this.listeners = listenersParam;
    };
    this.addListener = function (listener, key) {
      var _a;
      if (!_this.socketsConnected) {
        _this.dynamicListenersQueue.push({ listener: listener, key: key });
      } else {
        var callback =
          (_a = _this.listenWithStore) === null || _a === void 0
            ? void 0
            : _a.call(_this, listener);
        if (typeof callback === "function") {
          _this.dynamicListenersCallbacks[key] = callback;
        }
      }
    };
    this.removeListener = function (key) {
      var callback = _this.dynamicListenersCallbacks[key];
      if (typeof callback === "function") {
        callback();
      }
      delete _this.dynamicListenersCallbacks[key];
    };
    this.setFirstEmits = function (emits) {
      _this.runAsFirstEmitOnConnect = emits;
    };
    this.setBeforeConnectStarts = function (callback) {
      _this.beforeConnectStarts = callback;
    };
    this.setManagerEventsActions = function (event, action) {
      _this.managerAndSocketEventsActions[event] = action;
    };
    this.setSocketEmitWrapper = function (socketEmitWrapperParam) {
      _this.socketEmitWrapper = socketEmitWrapperParam;
    };
    this.connectionManager = function () {
      _this.getPushToEmitQueueFunction = _this.createEmitQueue();
      return {
        emitQueue: _this.getPushToEmitQueueFunction,
        closeConnection: _this.closeConnection,
        connectToSockets: _this.connectToSockets,
      };
    };
  }
  SocketConnectionManager.prototype.ackRequiredEmit = function (emitName) {
    var requiredEmitAckLeftIndex = this.requiredEmitsAckLeft.findIndex(
      function (requiredEmitAckLeft) {
        return requiredEmitAckLeft === emitName;
      }
    );
    if (requiredEmitAckLeftIndex > -1) {
      this.requiredEmitsAckLeft.splice(requiredEmitAckLeftIndex, 1);
      if (this.requiredEmitsAckLeft.length === 0) {
        this.toEmit = __spreadArray(
          __spreadArray([], this.toEmitAfterRequiredEmitsAck, true),
          this.toEmit,
          true
        );
        this.toEmitAfterRequiredEmitsAck = [];
      }
    }
  };
  SocketConnectionManager.prototype.runFirstEmitFromQueue = function () {
    var _this = this;
    // TODO implement better queue listening on socket status or acks?
    var emitFromQueue = this.toEmit.shift();
    if (this.socket && emitFromQueue) {
      var emitName_1 = emitFromQueue[0],
        newArgs_1 = emitFromQueue[1],
        ack = emitFromQueue[2];
      var isEmitRequired_1 = this.initialRequiredEmitsAck.includes(emitName_1);
      if (this.requiredEmitsAckLeft.length > 0 && !isEmitRequired_1) {
        this.toEmitAfterRequiredEmitsAck.push([emitName_1, newArgs_1, ack]);
        return false;
      }
      var newAckCallbackWrapper_1 = function (newAckCallback) {
        return function () {
          var ackArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            ackArgs[_i] = arguments[_i];
          }
          if (_this.isDebugMode()) {
            // eslint-disable-next-line no-console
            console.debug("ack - ".concat(emitName_1));
          }
          if (isEmitRequired_1) {
            _this.ackRequiredEmit(emitName_1);
          }
          if (typeof newAckCallback === "function") {
            newAckCallback.apply(void 0, ackArgs);
          }
          _this.runFirstEmitFromQueue();
        };
      };
      this.socketEmitWrapper(
        emitName_1,
        newArgs_1,
        ack,
        function (emitNameCallback, newArgsCallback, newAckCallback) {
          var _a, _b;
          if (newArgs_1.internalVolatile) {
            delete newArgs_1.internalVolatile;
            (_a = _this.socket) === null || _a === void 0
              ? void 0
              : _a.volatile.emit(
                  emitNameCallback,
                  newArgsCallback,
                  newAckCallbackWrapper_1(newAckCallback)
                );
          } else {
            (_b = _this.socket) === null || _b === void 0
              ? void 0
              : _b.emit(
                  emitNameCallback,
                  newArgsCallback,
                  newAckCallbackWrapper_1(newAckCallback)
                );
          }
        }
      );
      this.runFirstEmitFromQueue();
      return true;
    }
    return false;
  };
  /**
   * Use to set events that are required to receive ack before emitting more events.
   * @param requiredEmitsAck Array of event names that are required to receive ack
   */
  SocketConnectionManager.prototype.setRequiredEmitsAck = function (
    requiredEmitsAck
  ) {
    this.initialRequiredEmitsAck = requiredEmitsAck;
    this.requiredEmitsAckLeft = __spreadArray(
      [],
      this.initialRequiredEmitsAck,
      true
    );
  };
  return SocketConnectionManager;
})();
export default SocketConnectionManager;
